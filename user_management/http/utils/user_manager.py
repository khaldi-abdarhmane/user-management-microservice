"""UserManager custom component."""  # pylint: disable=duplicate-code
import logging
from collections.abc import AsyncGenerator
from typing import Any
from uuid import UUID

import jwt
from fastapi import Depends
from fastapi.requests import Request
from fastapi_users import (
    BaseUserManager,
    exceptions,
    InvalidID,
    InvalidPasswordException,
    schemas,
    UUIDIDMixin,
)
from fastapi_users.jwt import decode_jwt, generate_jwt
from fastapi_users_db_sqlalchemy import SQLAlchemyUserDatabase
from myem_lib.nameko_settings_mixins import NetworkClusterRpcClient
from nameko.exceptions import RemoteError
from sqlalchemy.ext.asyncio import AsyncSession
from user_management import get_url_for_role
from user_management.models import User
from user_management.http.config import get_async_session, settings


class UserManager(UUIDIDMixin, BaseUserManager[User, UUID]):
    """UserManager custom class."""

    reset_password_token_encode_secret = settings.private_key
    reset_password_token_decode_secret = settings.public_key
    verification_token_encode_secret = settings.private_key
    verification_token_decode_secret = settings.public_key
    reset_password_token_lifetime_seconds = 604800  # one week
    verification_token_lifetime_seconds = 604800

    def parse_id(self, value: Any) -> UUID:
        """Parse id as uuid if possible , raise exception otherwise."""
        try:
            return UUID(value)
        except ValueError as e:
            raise InvalidID() from e

    async def request_verify(self, user: User, request: Request | None = None) -> None:
        """Start a verification request.

        Triggers the on_after_request_verify handler on success.

        :param user: The user to verify.
        :param request: Optional FastAPI request that
        triggered the operation, defaults to None.
        :raises UserInactive: The user is inactive.
        :raises UserAlreadyVerified: The user is already verified.
        """
        if not user.is_active:
            raise exceptions.UserInactive()
        if user.is_verified:
            raise exceptions.UserAlreadyVerified()

        token_data = {
            "user_id": str(user.id),
            "email": user.email,
            "aud": self.verification_token_audience,
        }
        token = generate_jwt(
            token_data,
            self.verification_token_encode_secret,
            self.verification_token_lifetime_seconds,
            algorithm="RS256",
        )
        await self.on_after_request_verify(user, token, request)

    async def verify(self, token: str, request: Request | None = None) -> User:
        """Validate a verification request.

        Changes the is_verified flag of the user to True.

        Triggers the on_after_verify handler on success.

        :param token: The verification token generated by request_verify.
        :param request: Optional FastAPI request that
        triggered the operation, defaults to None.
        :raises InvalidVerifyToken: The token is invalid or expired.
        :raises UserAlreadyVerified: The user is already verified.
        :return: The verified user.
        """
        try:
            data = decode_jwt(
                token,
                self.verification_token_decode_secret,
                [self.verification_token_audience],
                algorithms=["RS256"],
            )
        except jwt.PyJWTError as exc:
            raise exceptions.InvalidVerifyToken() from exc

        try:
            user_id = data["user_id"]
            email = data["email"]
        except KeyError as exc:
            raise exceptions.InvalidVerifyToken() from exc

        try:
            user = await self.get_by_email(email)
        except exceptions.UserNotExists as exc:
            raise exceptions.InvalidVerifyToken() from exc

        try:
            parsed_id = self.parse_id(user_id)
        except exceptions.InvalidID as exc:
            raise exceptions.InvalidVerifyToken() from exc

        if parsed_id != user.id:
            raise exceptions.InvalidVerifyToken()

        if user.is_verified:
            raise exceptions.UserAlreadyVerified()

        verified_user = await self._update(user, {"is_verified": True})

        await self.on_after_verify(verified_user, request)

        return verified_user

    async def forgot_password(self, user: User, request: Request | None = None) -> None:
        """Start a forgot password request.

        Triggers the on_after_forgot_password handler on success.

        :param user: The user that forgot its password.
        :param request: Optional FastAPI request that
        triggered the operation, defaults to None.
        :raises UserInactive: The user is inactive.
        """
        if not user.is_active:
            raise exceptions.UserInactive()

        token_data = {
            "user_id": str(user.id),
            "aud": self.reset_password_token_audience,
        }
        token = generate_jwt(
            token_data,
            self.reset_password_token_encode_secret,
            self.reset_password_token_lifetime_seconds,
            algorithm="RS256",
        )
        await self.on_after_forgot_password(user, token, request)

    async def reset_password(
        self, token: str, password: str, request: Request | None = None
    ) -> User:
        """Reset the password of a user.

        Triggers the on_after_reset_password handler on success.

        :param token: The token generated by forgot_password.
        :param password: The new password to set.
        :param request: Optional FastAPI request that
        triggered the operation, defaults to None.
        :raises InvalidResetPasswordToken: The token is invalid or expired.
        :raises UserInactive: The user is inactive.
        :raises InvalidPasswordException: The password is invalid.
        :return: The user with updated password.
        """
        try:
            data = decode_jwt(
                token,
                self.reset_password_token_decode_secret,
                [self.reset_password_token_audience],
                algorithms=["RS256"],
            )
        except jwt.PyJWTError as exc:
            raise exceptions.InvalidResetPasswordToken() from exc

        try:
            user_id = data["user_id"]
        except KeyError as exc:
            raise exceptions.InvalidResetPasswordToken() from exc

        try:
            parsed_id = self.parse_id(user_id)
        except exceptions.InvalidID as exc:
            raise exceptions.InvalidResetPasswordToken() from exc

        user = await self.get(parsed_id)

        if not user.is_active:
            raise exceptions.UserInactive()

        updated_user = await self._update(user, {"password": password})

        await self.on_after_reset_password(user, request)

        return updated_user

    async def on_after_delete(self, user: User, request: Request | None = None) -> None:
        """Override of delete."""
        logging.info("user has been deleted successfully !")

    async def on_after_register(self, user: User, request: Request | None = None) -> None:
        """After register function, request verification email."""
        print(f"User {user.id} has registered, request verify.")
        if user.role in settings.customer_roles:
            with NetworkClusterRpcClient() as network_rpc:
                try:
                    network_rpc.customer_center_service.create_customer(
                        str(user.id), dict(user.address) if user.address else {}
                    )
                except RemoteError as e:
                    if e.value.find("utilisateur existe déjà") < 0:
                        await self.user_db.delete(user)
                        raise e
                except Exception as e:
                    await self.user_db.delete(user)
                    raise e
        if user.role in settings.auto_validate_roles:
            logging.info(
                f"Le compte de l'utilisateur {user.id} avec l'émail: {user.email} va etre validé."
            )
            verified_user = await self._update(user, {"is_verified": True})
            logging.info(
                f"Le compte de l'utilisateur {user.id} avec l'émail: {user.email} est validé."
            )
            url = get_url_for_role(verified_user.role, "/login")
            with NetworkClusterRpcClient() as network_rpc:
                network_rpc.email_notification.send_message.call_async(
                    {
                        "title": settings.email_confirmation_title,
                        "recipients": [
                            {"email": verified_user.email},
                        ],
                        "sender": {"email": settings.sender_email},
                        "html_body": f"""\
                        <html>
                          <body>
                            <p>Bonjour {verified_user.first_name},<br><br>
                            Votre espace est maintenant disponible à l'adresse suivante : {url}<br><br>
                            Cordialement,<br><br>
                            {settings.mail_signature}
                            </p>
                          </body>
                        </html>
                        """,
                    }
                )
        elif request is not None:
            with NetworkClusterRpcClient() as network_rpc:
                network_rpc.email_notification.send_message.call_async(
                    {
                        "title": "Inscription en cours de traitement",
                        # this object should contain user objects ? Do we send the ids
                        "recipients": [
                            {"email": user.email},
                        ],
                        "sender": {"email": settings.sender_email},
                        "html_body": f"""\
                        <html>
                          <body>
                            <p>Bonjour {user.first_name} {user.last_name},<br><br>
                            Merci de votre inscription. Celle-ci à bien été prise en compte.<br><br>
                            Nous sommes en train de la vérifier afin de vous inscrire à {settings.mail_signature}
                            Nous reviendrons vers vous une fois celle-ci
                            validée par l'administrateur.<br><br>
                            Cordialement,<br><br>
                            {settings.mail_signature}
                            </p>
                          </body>
                        </html>
                        """,
                    }
                )
                if settings.send_mail_to_admins_on_register:
                    admins = settings.network_admin_emails

                    network_rpc.email_notification.send_message.call_async(
                        {
                            "title": "Nouvelle inscription à votre Boucle Locale",
                            "recipients": [{"email": a} for a in admins],
                            "sender": {"email": settings.sender_email},
                            "html_body": f"""\
                            <html>
                              <body>
                                <p>Bonjour,<br><br>
                                Une nouvelle inscription est en attente de validation
                                sur votre espace administrateur: {settings.admin_url}<br>
                                Cordialement,<br><br>
                                {settings.mail_signature}
                                </p>
                              </body>
                            </html>
                            """,
                        }
                    )

    async def on_after_update(
        self,
        user: User,
        update_dict: dict[str, Any],
        request: Request | None = None,
    ) -> None:
        """After update function, do nothing for now."""
        await self.user_db.update(user, {"is_verified": True})
        print(f"User {user.id} has been updated with {update_dict}.")

    async def on_after_forgot_password(
        self, user: User, token: str, request: Request | None = None
    ) -> None:
        """Perform logic after successful forgot password request.

        *You should overload this method to add your own logic.*

        :param user: The user that forgot its password.
        :param token: The forgot password token.
        :param request: Optional FastAPI request that
        triggered the operation, defaults to None.
        """
        url = get_url_for_role(user.role, "/reset-password")
        with NetworkClusterRpcClient() as network_rpc:
            network_rpc.email_notification.send_message.call_async(
                {
                    "title": "Demande de réinitialisation de mot de passe",
                    "recipients": [
                        {"email": user.email},
                    ],
                    "sender": {"email": settings.sender_email},
                    "html_body": f"""\
                    <html>
                      <body>
                        <p>Bonjour {user.first_name} {user.last_name},<br><br>
                        Nous avons reçu une demande de réinitialisation de votre mot de passe,
                        <br><br>
                        Veuillez cliquer sur le lien suivant pour rentrer un nouveau mot de passe :
                        <a href="{url}?token={token}">lien de réinitialisation</a><br><br>
                        Si vous ne souhaitez pas réinitialiser votre mot de passe,
                        merci d’ignorer ce message.<br><br>
                        Merci <br><br>
                        {settings.mail_signature}
                        </p>
                      </body>
                    </html>
                    """,
                }
            )

    async def on_after_reset_password(self, user: User, request: Request | None = None) -> None:
        """After reset password, do nothing for now."""
        print(f"User {user.id} has reset their password.")

    async def on_after_login(self, user: User, request: Request | None = None) -> None:
        """After login function, do nothing for now."""
        logging.warning(f"User {user.id} has logged in.")

    async def on_after_request_verify(
        self, user: User, token: str, request: Request | None = None
    ) -> None:
        """After request verify function, send verification email."""
        # use request url for to have the url context with the absolute path,
        # url_path_for from the app will only give you relative path.
        if request is not None:
            with NetworkClusterRpcClient() as network_rpc:
                network_rpc.email_notification.send_message.call_async(
                    {
                        "title": settings.email_confirmation_title,
                        # this object should contain user objects ? Do we send the ids
                        "recipients": [
                            {"email": user.email},
                        ],
                        "sender": {"email": settings.sender_email},
                        "html_body": f"""\
                            <html>
                            <body>
                            <p>
                                Bonjour {user.first_name}, <br><br>
                                Nous avons bien reçu votre demande d'inscription, vous pouvez
                                valider votre compte en cliquant sur le
                                <a href="{request.url_for('verify:verify-view')}
                                ?token={token}">lien de validation</a><br><br>
                                {settings.mail_signature}
                            </p>
                            </body>
                            </html>
                            """,
                    }
                )
            print(f"User {user.id} has asked for email address verification.")

    async def validate_password(self, password: str, user: schemas.UC | User) -> None:
        """Password change validation."""
        if len(password) < 8:
            raise InvalidPasswordException(
                reason="Le mot de passe doit contenir au moins 8 caractères"
            )
        await super().validate_password(password, user)


async def get_user_db(
    session: AsyncSession = Depends(get_async_session),
) -> AsyncGenerator[SQLAlchemyUserDatabase[User, UUID], None]:
    """Async generator to get the user database."""
    yield SQLAlchemyUserDatabase[User, UUID](session, User)


async def get_user_manager(
    user_db: SQLAlchemyUserDatabase[User, UUID] = Depends(get_user_db),
) -> AsyncGenerator[UserManager, None]:
    """Async generator to get the user manager."""
    yield UserManager(user_db)